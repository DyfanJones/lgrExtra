% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AppenderDt.R
\name{AppenderDt}
\alias{AppenderDt}
\alias{lgr_data}
\title{Log to an in-memory data.table}
\description{
An Appender that outputs to an in-memory \code{data.table}. This kind of
Appender is useful for interactive use, and has very little overhead.
}
\section{Custom Fields}{


\code{AppenderDt} supports \link[=LogEvent]{custom fields}, but they have to be
pre-allocated in the \code{prototype} argument. Custom fields that are not
part of the prototype are discarded. If you want an Appender that retains
all custom fields (at the cost of slightly less performance), take a look at
\link{AppenderBuffer}.

With the default settings, the custom field \code{value} is included in the
\code{data.table} as a list column to store arbitrary \R objects (see example).
It is recommended to use this feature only \code{TRACE} level.
}

\section{Creating a Data Table Appender}{


In addition to the usual fields, \code{AppenderDt$new()} requires that you supply
a \code{buffer_size} and a \code{prototype}. These determine the structure of the
\code{data.table} used to store the log this appender creates and cannot be
modified anymore after the instantiation of the appender.

The \link{Layout} for this Appender is used only to format console output of
its \verb{$show()} method.

\describe{
\item{buffer_size}{\code{integer} scalar. Number of rows of the in-memory
\code{data.table}}
\item{prototype}{A prototype \code{data.table}. The prototype must be a
\code{data.table} with the same columns and column types as the data
you want to log. The actual content of the columns is irrelevant.
There are a few columns that have special meaning, based on their name:
\itemize{
\item{\code{.id}: \code{integer} (mandatory). Must always be the first column
and is used internally by the Appender}
\item{\code{.custom}: \code{list} (optional). If present all custom values of the
event (that are not already part of the prototype) are stored in
this list column.}
}
}
}
}

\section{Fields}{


\describe{
\item{\code{dt}}{Get the log recorded by this \code{Appender} as a \code{data.table}
with a maximum of \code{buffer_size} rows}
}
}

\section{Methods}{

\describe{
\item{\code{show(n, threshold)}}{Show the last \code{n} log entries with a log level
bellow \code{threshold}. The log entries will be formatted for console output
via this Appenders \link{Layout}}
}
}

\section{Comparison AppenderBuffer and AppenderDt}{


Both \link{AppenderBuffer} and \link{AppenderDt} do in memory buffering of events.
AppenderBuffer retains a copies of the events it processes and has the
ability to pass the buffered events on to other Appenders. AppenderDt
converts the events to rows in a \code{data.table} and is a bit harder to
configure. Used inside loops (several hundred iterations),
AppenderDt has much less overhead than AppenderBuffer. For single logging
calls and small loops, AppenderBuffer is more performant. This is related to
how memory pre-allocation is handled by the appenders.

In short: Use AppenderDt if you want an in-memory log for interactive use,
and AppenderBuffer if you actually want to buffer events
}

\examples{
lg <- lgr::get_logger("test")
lg$config(list(
  appenders = list(memory = AppenderDt$new()),
  threshold = NA,
  propagate = FALSE  # to prevent routing to root logger for this example
))
lg$debug("test")
lg$error("test")

# Displaying the log
lg$appenders$memory$data
lg$appenders$memory$show()
lgr::show_log(target = lg$appenders$memory)

# If you pass a Logger to show_log(), it looks for the first AppenderDt
# that it can find.
lgr::show_log(target = lg)

# Custom fields are stored in the list column .custom by default
lg$info("the iris data frame", caps = LETTERS[1:5])
lg$appenders$memory$data
lg$appenders$memory$data$.custom[[3]]$caps
lg$config(NULL)
}
\seealso{
\link{LayoutFormat}, \link{simple_logging}, \link[data.table:data.table]{data.table::data.table}
}
